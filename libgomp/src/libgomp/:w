/* Copyright (C) 2005-2014 Free Software Foundation, Inc.
   Contributed by Richard Henderson <rth@redhat.com>.

   This file is part of the GNU OpenMP Library (libgomp).

   Libgomp is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
   more details.

   Under Section 7 of GPL version 3, you are granted additional
   permissions described in the GCC Runtime Library Exception, version
   3.1, as published by the Free Software Foundation.

   You should have received a copy of the GNU General Public License and
   a copy of the GCC Runtime Library Exception along with this program;
   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   <http://www.gnu.org/licenses/>.  */

/* This file contains routines for managing work-share iteration, both
   for loops and sections.  */

#include "libgomp.h"
#include <stdlib.h>
#include <stdio.h>
#include <inttypes.h>
#include <assert.h>
#include <math.h>
#include <string.h>
#include <time.h>
/* This function implements the STATIC scheduling method.  The caller should
   iterate *pstart <= x < *pend.  Return zero if there are more iterations
   to perform; nonzero if not.  Return less than 0 if this thread had
   received the absolutely last iteration.  */

int
gomp_iter_static_next (long *pstart, long *pend)
{
  struct gomp_thread *thr = gomp_thread ();
  struct gomp_team *team = thr->ts.team;
  struct gomp_work_share *ws = thr->ts.work_share;
  unsigned long nthreads = team ? team->nthreads : 1;

  if (thr->ts.static_trip == -1)
    return -1;

  /* Quick test for degenerate teams and orphaned constructs.  */
  if (nthreads == 1)
    {
      *pstart = ws->next;
      *pend = ws->end;
      thr->ts.static_trip = -1;
      return ws->next == ws->end;
    }

  /* We interpret chunk_size zero as "unspecified", which means that we
     should break up the iterations such that each thread makes only one
     trip through the outer loop.  */
  if (ws->chunk_size == 0)
    {
      unsigned long n, q, i, t;
      unsigned long s0, e0;
      long s, e;

      if (thr->ts.static_trip > 0)
	return 1;

      /* Compute the total number of iterations.  */
      s = ws->incr + (ws->incr > 0 ? -1 : 1);
      n = (ws->end - ws->next + s) / ws->incr;
      i = thr->ts.team_id;

      /* Compute the "zero-based" start and end points.  That is, as
         if the loop began at zero and incremented by one.  */
      q = n / nthreads;
      t = n % nthreads;
      if (i < t)
	{
	  t = 0;
	  q++;
	}
      s0 = q * i + t;
      e0 = s0 + q;

      /* Notice when no iterations allocated for this thread.  */
      if (s0 >= e0)
	{
	  thr->ts.static_trip = 1;
	  return 1;
	}

      /* Transform these to the actual start and end numbers.  */
      s = (long)s0 * ws->incr + ws->next;
      e = (long)e0 * ws->incr + ws->next;

      *pstart = s;
      *pend = e;
      thr->ts.static_trip = (e0 == n ? -1 : 1);
      return 0;
    }
  else
    {
      unsigned long n, s0, e0, i, c;
      long s, e;

      /* Otherwise, each thread gets exactly chunk_size iterations
	 (if available) each time through the loop.  */

      s = ws->incr + (ws->incr > 0 ? -1 : 1);
      n = (ws->end - ws->next + s) / ws->incr;
      i = thr->ts.team_id;
      c = ws->chunk_size;

      /* Initial guess is a C sized chunk positioned nthreads iterations
	 in, offset by our thread number.  */
      s0 = (thr->ts.static_trip * nthreads + i) * c;
      e0 = s0 + c;

      /* Detect overflow.  */
      if (s0 >= n)
	return 1;
      if (e0 > n)
	e0 = n;

      /* Transform these to the actual start and end numbers.  */
      s = (long)s0 * ws->incr + ws->next;
      e = (long)e0 * ws->incr + ws->next;

      *pstart = s;
      *pend = e;

      if (e0 == n)
	thr->ts.static_trip = -1;
      else
	thr->ts.static_trip++;
      return 0;
    }
}


/* This function implements the DYNAMIC scheduling method.  Arguments are
   as for gomp_iter_static_next.  This function must be called with ws->lock
   held.  */

bool
gomp_iter_dynamic_next_locked (long *pstart, long *pend)
{
  struct gomp_thread *thr = gomp_thread ();
  struct gomp_work_share *ws = thr->ts.work_share;
  long start, end, chunk, left;

  start = ws->next;
  if (start == ws->end)
    return false;

  chunk = ws->chunk_size;
  left = ws->end - start;
  if (ws->incr < 0)
    {
      if (chunk < left)
	chunk = left;
    }
  else
    {
      if (chunk > left)
	chunk = left;
    }
  end = start + chunk;

  ws->next = end;
  *pstart = start;
  *pend = end;
  return true;
}


#ifdef HAVE_SYNC_BUILTINS
/* Similar, but doesn't require the lock held, and uses compare-and-swap
   instead.  Note that the only memory value that changes is ws->next.  */

bool
gomp_iter_dynamic_next (long *pstart, long *pend)
{
  struct gomp_thread *thr = gomp_thread ();
  struct gomp_work_share *ws = thr->ts.work_share;
  long start, end, nend, chunk, incr;

  end = ws->end;
  incr = ws->incr;
  chunk = ws->chunk_size;

  if (__builtin_expect (ws->mode, 1))
    {
      long tmp = __sync_fetch_and_add (&ws->next, chunk);
      if (incr > 0)
	{
	  if (tmp >= end)
	    return false;
	  nend = tmp + chunk;
	  if (nend > end)
	    nend = end;
	  *pstart = tmp;
	  *pend = nend;
	  return true;
	}
      else
	{
	  if (tmp <= end)
	    return false;
	  nend = tmp + chunk;
	  if (nend < end)
	    nend = end;
	  *pstart = tmp;
	  *pend = nend;
	  return true;
	}
    }

  start = ws->next;
  while (1)
    {
      long left = end - start;
      long tmp;

      if (start == end)
	return false;

      if (incr < 0)
	{
	  if (chunk < left)
	    chunk = left;
	}
      else
	{
	  if (chunk > left)
	    chunk = left;
	}
      nend = start + chunk;

      tmp = __sync_val_compare_and_swap (&ws->next, start, nend);
      if (__builtin_expect (tmp == start, 1))
	break;

      start = tmp;
    }

  *pstart = start;
  *pend = nend;
  return true;
}

/*int ipow(int base, int exp)
{
    int result = 1;
	    while (exp)
	    {
	        if (exp & 1) result *= base;
			exp >>= 1;
	        base *= base;
	    }
    return result;
}

int iround(double x)
{
    if (x < 0.0)
        return (int)(x - 0.5);
    else
        return (int)(x + 0.5);
}*/

//This is probably very unsafe. 
int globalfactcounter = -1;
int maxworkload = 0;

extern unsigned __ntasks; 
bool
gomp_iter_fact_next (long *pstart, long *pend)
{
  //printf("hi");
  struct gomp_thread *thr = gomp_thread ();
  struct gomp_work_share *ws = thr->ts.work_share;
  struct gomp_team *team = thr->ts.team;
  unsigned long nthreads = team ? team->nthreads : 1;
  long start, end, nend;// incr;
  unsigned long chunk_size;
  start = ws->next;
  end = ws->end;
  //incr = ws->incr;
  chunk_size = ws->chunk_size;
  if (globalfactcounter == -1) maxworkload = (end-start);///incr;
  __sync_add_and_fetch(&globalfactcounter, 1);
  while (1)
    {
      unsigned long n, q;
      long tmp;

      if (start == end)
	return false;
      n = (end - start); /// incr;
	  //if (globalfactcounter%nthreads == 0) {
	  int blatest = (globalfactcounter/nthreads)+1;
	  q = ceil((double) maxworkload /(pow(2, blatest)* nthreads)); 
	  //q = q >>blatest;
	//__sync_fetch_and_add(&globalfactcounter, 1);
	//q = (n + nthreads - 1) / (2*nthreads);
	//currentworkload = q;
	  //}
	  //else {
	//__sync_fetch_and_add(&globalfactcounter, 1);
	//q = currentworkload;
	  //}
      if (q < chunk_size)
	q = chunk_size;
      if (__builtin_expect (q <= n, 1))
	nend = start + q;
      else
	nend = end;

      tmp = __sync_val_compare_and_swap (&ws->next, start, nend);
      if (__builtin_expect (tmp == start, 1)){

printf("%ld ,q: %ld, n: %ld, thrNr: %i, end: %ld,  nend: %ld\n", start, q, n, omp_get_thread_num(), end,  nend);
break;}
	  //printf("\nhi\n");
	 // __sync_sub_and_fetch(&globalfactcounter, 1);
      start = tmp;
    }
 // printf("threadid: %d, start %ld, end %ld\n", omp_get_thread_num(), start, end);

  *pstart = start;
  *pend = nend;
  return true;
}
//This is probably very unsafe. 
/*int globalfactcounter = -1;
int currentworkload = 0;

extern unsigned __ntasks; 
bool
gomp_iter_fact_next (long *pstart, long *pend)
{
  struct gomp_thread *thr = gomp_thread ();
  struct gomp_work_share *ws = thr->ts.work_share;
  struct gomp_team *team = thr->ts.team;
  unsigned long nthreads = team ? team->nthreads : 1;
  long start, end, nend, incr;
  unsigned long chunk_size;
  start = ws->next;
  end = ws->end;
  incr = ws->incr;
  chunk_size = ws->chunk_size;
  
  while (1)
    {
      unsigned long n, q;
      long tmp;

      if (start == end)
	return false;
	__sync_fetch_and_add(&globalfactcounter, 1);
      n = (end - start) / incr;
	  if (globalfactcounter%nthreads == 0) {
	//__sync_fetch_and_add(&globalfactcounter, 1);
	q = (n + nthreads - 1) / (2*nthreads);
	currentworkload = q;
	  }
	  else {
	//__sync_fetch_and_add(&globalfactcounter, 1);
	q = currentworkload;
	  }
//printf("q: %ld, n: %ld, nthreads: %ld\n", q, n, nthreads);
      if (q < chunk_size)
	q = chunk_size;
      if (__builtin_expect (q <= n, 1))
	nend = start + q * incr;
      else
	nend = end;

printf("q: %ld, n: %ld, nthreads: %ld, start: %ld, end: %ld, incr: %ld, nend: %ld\n", q, n, nthreads, start, end, incr, nend);
      tmp = __sync_val_compare_and_swap (&ws->next, start, nend);
      if (__builtin_expect (tmp == start, 1))
	break;

      start = tmp;
    }

  *pstart = start;
  *pend = nend;
  return true;
}*/
bool
gomp_iter_frac_next (long *pstart, long *pend)
{return true;

}

double sigma = 0;
double alpha = 1.3;
double mue = 0;
double va = 0; 
bool
gomp_iter_tape_next (long *pstart, long *pend)
{
//printf("hi");
  struct gomp_thread *thr = gomp_thread ();
  struct gomp_work_share *ws = thr->ts.work_share;
  struct gomp_team *team = thr->ts.team;
  unsigned long nthreads = team ? team->nthreads : 1;
  long start, end, nend;// incr;
  unsigned long chunk_size;
  start = ws->next;
  end = ws->end;
  sigma = atoi(getenv("SIGMA"));
  alpha = atoi(getenv("ALPHA"));
  mue = atoi(getenv("MUE"));
  //incr = ws->incr;
  va = (alpha*sigma)/mue;
  //double Ki = (Ti + ((va*va)/2) - (va*sqrt(2*Ti+((va*va)/4))));
  chunk_size = ws->chunk_size;
  //if (globalfactcounter == -1) maxworkload = (end-start);///incr;
  //__sync_add_and_fetch(&globalfactcounter, 1);
  while (1)
    {
      unsigned long n, q;
      long tmp;
	double Ti = (end - start)/nthreads;
      if (start == end)
	return false;
      n = (end - start); /// incr;
	  //if (globalfactcounter%nthreads == 0) {
	  q =  (Ti + ((va*va)/2) - (va*sqrt(2*Ti+((va*va)/4))));
	  //q = q >>blatest;
	//__sync_fetch_and_add(&globalfactcounter, 1);
	//q = (n + nthreads - 1) / (2*nthreads);
	//currentworkload = q;
	  //}
	  //else {
	//__sync_fetch_and_add(&globalfactcounter, 1);
	//q = currentworkload;
	  //}
      if (q < chunk_size)
	q = chunk_size;
      if (__builtin_expect (q <= n, 1))
	nend = start + q;
      else
	nend = end;

      tmp = __sync_val_compare_and_swap (&ws->next, start, nend);
      if (__builtin_expect (tmp == start, 1)){

printf("%ld ,q: %ld, n: %ld, thrNr: %i, end: %ld,  nend: %ld\n", start, q, n, omp_get_thread_num(), end,  nend);
break;}
	  //printf("\nhi\n");
	 // __sync_sub_and_fetch(&globalfactcounter, 1);
      start = tmp;
    }
 // printf("threadid: %d, start %ld, end %ld\n", omp_get_thread_num(), start, end);

  *pstart = start;
  *pend = nend;
  return true;

}

int globalWFACcounter = -1;
int WFACworkload = 0;

double *asdf;
bool
gomp_iter_wfac_next (long *pstart, long *pend)
{
  //printf("hi");
  struct gomp_thread *thr = gomp_thread ();
  struct gomp_work_share *ws = thr->ts.work_share;
  struct gomp_team *team = thr->ts.team;
  unsigned long nthreads = team ? team->nthreads : 1;
  long start, end, nend, incr;
  unsigned long chunk_size;
  start = ws->next;
  end = ws->end;
  incr = ws->incr;
  asdf = (double*)malloc(sizeof(double) * nthreads);
  char * pch;
  pch = strtok (getenv("WEIGHTS")," ");
  int tempvarwfac = 0; 
  while(pch != NULL) {
    asdf[tempvarwfac] = strtod(pch,NULL);
	tempvarwfac++;
 	pch = strtok(NULL, " "); 
  }
  chunk_size = ws->chunk_size;
  if (globalfactcounter == -1) maxworkload = (end-start)/incr;
  __sync_add_and_fetch(&globalfactcounter, 1);
  while (1)
    {
      unsigned long n, q;
      long tmp;

      if (start == end)
	return false;
      n = (end - start) / incr;
	  //if (globalfactcounter%nthreads == 0) {
	  int blatest = (globalfactcounter/nthreads)+1;
	  q = round(asdf[omp_get_thread_num()]*((maxworkload) / (pow(2,blatest) * nthreads))); 
	//__sync_fetch_and_add(&globalfactcounter, 1);
	//q = (n + nthreads - 1) / (2*nthreads);
	//currentworkload = q;
	  //}
	  //else {
	//__sync_fetch_and_add(&globalfactcounter, 1);
	//q = currentworkload;
	  //}
      if (q < chunk_size)
	q = chunk_size;
      if (__builtin_expect (q <= n, 1))
	nend = start + q * incr;
      else
	nend = end;

      tmp = __sync_val_compare_and_swap (&ws->next, start, nend);
      if (__builtin_expect (tmp == start, 1)){

printf("%ld ,q: %ld, n: %ld, thrNr: %i, end: %ld, incr: %ld, nend: %ld\n", start, q, n, omp_get_thread_num(), end, incr, nend);
break;}
	  //printf("\nhi\n");
	 // __sync_sub_and_fetch(&globalfactcounter, 1);
      start = tmp;
    }
 // printf("threadid: %d, start %ld, end %ld\n", omp_get_thread_num(), start, end);

  *pstart = start;
  *pend = nend;
  return true;
}

double boldsigma = 0;
double boldmue = 0;
double boldh = 0.5; 
double bolda = 0;
double boldb= 0;
double ln_b = 0;
double p_inv = 0;
double c1 = 0;
double c2 = 0;
double c3 = 0;
double boldm = 0;
double boldn = 0;
int boldcounter = 0;
bool boldinit = false;
double totalspeed = 0;
double boldtime = time(NULL);
#ifndef max
    #define max(a,b) ((a) > (b) ? (a) : (b))
#endif
#ifndef min
    #define min(a,b) ((a) < (b) ? (a) : (b))
#endif
double *boldarray;
double *speedarray;
bool
gomp_iter_bold_next (long *pstart, long *pend)
{
struct gomp_thread *thr = gomp_thread ();
  struct gomp_work_share *ws = thr->ts.work_share;
  struct gomp_team *team = thr->ts.team;
  unsigned long nthreads = team ? team->nthreads : 1;
  long start, end, nend;// incr;
  unsigned long chunk_size;
  start = ws->next;
  end = ws->end;
  
  if (boldcounter == 0){
  boldsigma = atoi(getenv("BOLDSIGMA"));
  boldmue = atoi(getenv("BOLDMUE"));
  boldh = atoi(getenv("BOLDH"));
  //incr = ws->incr;
  bolda = 2*((boldsigma/boldmue)*(boldsigma/boldmue));
  boldb = 8*bolda*log(8*bolda);
  if (boldb > 0) ln_b = log(boldb);
  p_inv = 1.0/nthreads;
  c1 = boldh/(boldmue*log(2));
  c2 = sqrt(2*M_PI*c1);
  c3 = log(c2);
  boldm = end;
  boldn = end;
  boldarray = (double*)malloc(sizeof(double) * nthreads); 
  for (int i = 0; i < nthreads; i++){ boldarray[i] = 0;}
  speedarray = (double*)malloc(sizeof(double) * nthreads); 
  for (int i = 0; i < nthreads; i++){ speedarray[i] = 0;}
  
  boldinit = true;
  }
  if (boldinit){ boldm = boldm - boldarray[omp_get_thread_num()];
       totalspeed -= speedarray[omp_get_thread_num()];
	   
	   }
  //double Ki = (Ti + ((va*va)/2) - (va*sqrt(2*Ti+((va*va)/4))));
  chunk_size = ws->chunk_size;
  //if (globalfactcounter == -1) maxworkload = (end-start);///incr;
  //__sync_add_and_fetch(&globalfactcounter, 1);
  while (1)
    {
	  if (!boldinit) continue;	
	  double n, q;
      long tmp;
	//double Ti = (end - start)/nthreads;
      if (start == end)
	return false;
	  n = (end - start); /// incr;
	  q = n/nthreads;
	  double r = max(n,boldn);
	  double t = p_inv * r;
	  double ln_Q = log(q);
	  double v = q/(boldb+q);
	  double d = n/(1+(1/ln_Q)-v);
	  if(d<=c2) q = t;
	  double s = bolda*(log(d)-c3)*(1+(boldm/(r*nthreads)));
	  double w = 0;
	  if (boldb > 0) w = log(v*ln_Q)+ln_b;
	  else w = log(ln_Q);
	  q = min(t+max(0,c1*w)+(s/2)-sqrt(s*(t+(s/4))),t);
	  //if (globalfactcounter%nthreads == 0) {
	  //q =  (Ti + ((va*va)/2) - (va*sqrt(2*Ti+((va*va)/4))));
	  //q = q >>blatest;
	//__sync_fetch_and_add(&globalfactcounter, 1);
	//q = (n + nthreads - 1) / (2*nthreads);
	//currentworkload = q;
	  //}
	  //else {
	//__sync_fetch_and_add(&globalfactcounter, 1);
	//q = currentworkload;
	  //}
      if (q < chunk_size)
	q = chunk_size;
      if (__builtin_expect (q <= n, 1))
	nend = start + q;
      else
	nend = end;

      tmp = __sync_val_compare_and_swap (&ws->next, start, nend);
      if (__builtin_expect (tmp == start, 1)){
		boldarray[omp_get_thread_num()] = q;
		totalspeed += q/((q*boldmue)+boldh);
		speedarray[omp_get_thread_num()] = q/((q*boldmue)+boldh);
//printf("%ld ,q: %ld, n: %ld, thrNr: %i, end: %ld,  nend: %ld\n", start, q, n, omp_get_thread_num(), end,  nend);
break;}
	  //printf("\nhi\n");
	 // __sync_sub_and_fetch(&globalfactcounter, 1);
      start = tmp;
    }
 // printf("threadid: %d, start %ld, end %ld\n", omp_get_thread_num(), start, end);

  *pstart = start;
  *pend = nend;
  return true;


}

int trapcounter = -1;
int decr_delta = 0;
int startsize = 0;
bool
gomp_iter_trap_next (long *pstart, long *pend)
{
  //printf("hi");
  struct gomp_thread *thr = gomp_thread ();
  struct gomp_work_share *ws = thr->ts.work_share;
  //struct gomp_team *team = thr->ts.team;
  //unsigned long nthreads = team ? team->nthreads : 1;
  long start, end, nend;// incr;
  unsigned long chunk_size;
  start = ws->next;
  end = ws->end;
  //incr = ws->incr;
  chunk_size = ws->chunk_size;
  int mynumber = __sync_add_and_fetch(&trapcounter, 1);
  //unsigned long testn = 0;
	if (trapcounter == 0 || decr_delta == 0 || startsize == 0) {
	 // printf("Trapezoid started \n");
	  start = ws->next;
	  end = ws->end;
	  //incr = ws->incr;
	  chunk_size = ws->chunk_size;
	  startsize = atoi(getenv("TRAPSTART"));
	  int endsize = atoi(getenv("TRAPEND"));
	  //testn = (end - start) / incr;
	  int big_n = (2*end)/(startsize+endsize);
	  if (big_n != 1) decr_delta = (startsize - endsize)/(big_n - 1);
	 // printf("start: %i, end: %i\n",startsize,endsize);
	 //   printf("bign: %i, decr: %i\n",big_n,decr_delta);
	  }
 // printf("trapcounter: %i\n", trapcounter);
  /*if (decr_delta == 0 || startsize == 0){
  __sync_sub_and_fetch(&trapcounter, 1);
  *pstart = start;
  *pend = end; 
  return true;
  }*/
  while (1) {

	unsigned long n, q;
	long tmp;
	if (start == end)	return false;
	q = 0;
	if(startsize != 0 && decr_delta !=0) {
		q = startsize - (decr_delta * mynumber);
	}
	n = (end - start);// / incr;
	//printf("q: %ld, n: %ld, nthreads: %ld", q, n, nthreads);
	if (q < chunk_size)
	q = chunk_size;
	if (__builtin_expect (q <= n, 1)) nend = start + q;
	else nend = end;
	tmp = __sync_val_compare_and_swap (&ws->next, start, nend);
	if (__builtin_expect (tmp == start, 1)) {
printf("%i, trapcounter: %i, q: %ld, n: %ld, threadNr: %i, start: %ld, end: %ld, nend: %ld\n", mynumber, trapcounter, q, n, omp_get_thread_num(), start, end,  nend);
	break;}
	start = tmp;
  }
    *pstart = start;
  *pend = nend;
  return true;
}


bool
gomp_iter_binlpt_next (long *pstart, long *pend)
{
  int i, j;                   /* Loop index.           */
  int tid;                    /* Thread ID.            */
  int start;                  /* Start of search.      */
  struct gomp_thread *thr;    /* Thread.               */
  struct gomp_work_share *ws; /* Work-Share construct. */

  thr = gomp_thread();
  ws = thr->ts.work_share;
  tid = omp_get_thread_num();
  /* Search for next task. */
  start = ws->thread_start[tid];
  for (i = start; i < __ntasks; i++)
  {
     if (ws->taskmap[i] == tid)
       goto found;
  }

  return (false);

found:

  for (j = i + 1; j < __ntasks; j++)
  {
     if (ws->taskmap[j] != tid)
       break;
  }

	ws->thread_start[tid] = j;
	*pstart = ws->loop_start + i;
	*pend = ws->loop_start + j;

	return (true);
}

bool
gomp_iter_srr_next (long *pstart, long *pend)
{
  int i;                      /* Loop index.           */
  int tid;                    /* Thread ID.            */
  int start;                  /* Start of search.      */
  struct gomp_thread *thr;    /* Thread.               */
  struct gomp_work_share *ws; /* Work-Share construct. */

  thr = gomp_thread();
  ws = thr->ts.work_share;
  tid = omp_get_thread_num();

  /* Search for next task. */
  start = ws->thread_start[tid];
  for (i = start; i < __ntasks; i++)
  {
     if (ws->taskmap[i] == tid)
       goto found;
  }

  return (false);

found:

	ws->thread_start[tid] = i + 1;
	*pstart = ws->loop_start + i;
	*pend = ws->loop_start + i + 1;

	return (true);
}

#endif /* HAVE_SYNC_BUILTINS */

/* This function implements the GUIDED scheduling method.  Arguments are
   as for gomp_iter_static_next.  This function must be called with the
   work share lock held.  */

bool
gomp_iter_guided_next_locked (long *pstart, long *pend)
{
  struct gomp_thread *thr = gomp_thread ();
  struct gomp_work_share *ws = thr->ts.work_share;
  struct gomp_team *team = thr->ts.team;
  unsigned long nthreads = team ? team->nthreads : 1;
  unsigned long n, q;
  long start, end;

  if (ws->next == ws->end)
    return false;

  start = ws->next;
  n = (ws->end - start) / ws->incr;
  q = (n + nthreads - 1) / nthreads;

  if (q < ws->chunk_size)
    q = ws->chunk_size;
  if (q <= n)
    end = start + q * ws->incr;
  else
    end = ws->end;

  ws->next = end;
  *pstart = start;
  *pend = end;
  return true;
}

#ifdef HAVE_SYNC_BUILTINS
/* Similar, but doesn't require the lock held, and uses compare-and-swap
   instead.  Note that the only memory value that changes is ws->next.  */

bool
gomp_iter_guided_next (long *pstart, long *pend)
{
  struct gomp_thread *thr = gomp_thread ();
  struct gomp_work_share *ws = thr->ts.work_share;
  struct gomp_team *team = thr->ts.team;
  unsigned long nthreads = team ? team->nthreads : 1;
  long start, end, nend, incr;
  unsigned long chunk_size;

  start = ws->next;
  end = ws->end;
  incr = ws->incr;
  chunk_size = ws->chunk_size;

  while (1)
    {
      unsigned long n, q;
      long tmp;

      if (start == end)
	return false;

      n = (end - start) / incr;
      q = (n + nthreads - 1) / nthreads;

      if (q < chunk_size)
	q = chunk_size;
      if (__builtin_expect (q <= n, 1))
	nend = start + q * incr;
      else
	nend = end;

      tmp = __sync_val_compare_and_swap (&ws->next, start, nend);
      if (__builtin_expect (tmp == start, 1))
	break;

      start = tmp;
    }

  *pstart = start;
  *pend = nend;
  return true;
}
#endif /* HAVE_SYNC_BUILTINS */
